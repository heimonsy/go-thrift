// Copyright 2012-2015 Samuel Stauffer. All rights reserved.
// Use of this source code is governed by a 3-clause BSD
// license that can be found in the LICENSE file.

package main

import (
	"bytes"
	"io/ioutil"
	"os"
	"testing"

	"github.com/samuel/go-thrift/parser"
)

func TestTypedefs(t *testing.T) {
	p := &parser.Parser{}
	th, err := p.Parse(bytes.NewBuffer([]byte(`
		typedef binary Binary
		typedef string String
		typedef i32    Int32

		struct St {
			1: Binary b,
			2: String s,
			3: Int32 i
		}
	`)))
	if err != nil {
		t.Fatal(err)
	}

	path, err := ioutil.TempDir("", "go-thrift-")
	if err != nil {
		t.Fatal(err)
	}
	defer os.RemoveAll(path)

	// Use pointers

	generator := &GoGenerator{
		ThriftFiles: map[string]*parser.Thrift{"typedefs": th},
		Format:      true,
		Pointers:    true,
	}
	err = generator.Generate(path)
	if err != nil {
		t.Fatal(err)
	}

	fileEquals(t, path+"/typedefs/typedefs.go", `// This file is automatically generated. Do not modify.

package typedefs

import (
	"fmt"
)

var _ = fmt.Sprintf

type Binary []byte
type Int32 int32
type String string

type St struct {
	B *Binary `+"`"+`thrift:"1,required" json:"b"`+"`"+`
	S *String `+"`"+`thrift:"2,required" json:"s"`+"`"+`
	I *Int32  `+"`"+`thrift:"3,required" json:"i"`+"`"+`
}
`)

	// Don't use pointers

	generator.Pointers = false
	err = generator.Generate(path)
	if err != nil {
		t.Fatal(err)
	}

	fileEquals(t, path+"/typedefs/typedefs.go", `// This file is automatically generated. Do not modify.

package typedefs

import (
	"fmt"
)

var _ = fmt.Sprintf

type Binary []byte
type Int32 int32
type String string

type St struct {
	B Binary `+"`"+`thrift:"1,required" json:"b"`+"`"+`
	S String `+"`"+`thrift:"2,required" json:"s"`+"`"+`
	I Int32  `+"`"+`thrift:"3,required" json:"i"`+"`"+`
}
`)
}

func cat(t *testing.T, path string) {
	b, err := ioutil.ReadFile(path)
	if err != nil {
		t.Fatalf("Failed to read %s: %s", path, err)
	}
	t.Log(string(b))
}

func fileEquals(t *testing.T, path, content string) {
	b, err := ioutil.ReadFile(path)
	if err != nil {
		t.Fatalf("Failed to read %s: %s", path, err)
	}
	s := string(b)
	if s != content {
		t.Fatalf("Expected\n%s\ngot\n%s", content, s)
	}
}
